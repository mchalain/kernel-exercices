Exercice 1:
 Compiler le driver:
 > make
 Mettre une résistance sur le 3.3V.
 Mettre un fil sur le GPIO 21.
 Insérer le module:
 > sudo insmod mysdriver1.ko
 Ouvrir le fichier device:
 > sudo cat /dev/mydriver
 Faire toucher le fil et la rśesistance par intermitence. 
 La sortie du cat ne nécessite plus un Ctrl+C et une IT.

Exercice 2:
 Ouvrir une console ssh sur la board.
 Visualiser les taches en cours avec top.
 > top
 2634 pi        20   0    8096   3324   2796 R  2.3  0.7   0:13.20 top          
 2272 pi        20   0   11608   3836   3072 S  0.3  0.9   0:01.78 sshd         
    1 root      20   0    9640   6084   4932 S  0.0  1.4   0:04.17 systemd      
    2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd     
    3 root      20   0       0      0      0 S  0.0  0.0   0:01.34 ksoftirqd/0  
    5 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H 
    7 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 lru-add-dra+ 
    8 root      20   0       0      0      0 S  0.0  0.0   0:00.01 kdevtmpfs    
 Dans l'autre console faire l'exercice 1.
 Remarquer la tache ksoftirqd dont l'utilisation CPU augmente quand le bottom_half est appelé.

Exercice 3:
 Un type de traitement d'IT permet de créer un thread depuis le handler.
 Utiliser la fonction request_threaded_irq puis le retour IRQ_WAKE_THREAD dans le handler.

 trouver la solution avec git checkout irq.5

